## 1. Какой системный вызов делает команда ``cd``? В прошлом ДЗ мы выяснили, что ``cd`` не является самостоятельной программой, это ``shell builtin``, поэтому запустить strace непосредственно на cd не получится. Тем не менее, вы можете запустить ``strace на /bin/bash -c 'cd /tmp'``. В этом случае вы увидите полный список системных вызовов, которые делает сам ``bash`` при старте. Вам нужно найти тот единственный, который относится именно к ``cd``.  

системный вызов команды CD -> chdir("/tmp") в нашем случае. 

## 2. Попробуйте использовать команду file на объекты разных типов на файловой системе. Например:
```bash
vagrant@netology1:~$ file /dev/tty
/dev/tty: character special (5/0)
vagrant@netology1:~$ file /dev/sda
/dev/sda: block special (8/0)
vagrant@netology1:~$ file /bin/bash
/bin/bash: ELF 64-bit LSB shared object, x86-64
```
## Используя strace выясните, где находится база данных file на основании которой она делает свои догадки.
Файл базы типов - /usr/share/misc/magic.mgc

в тексте это:

```openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3```

Также идёт поиск в домашнем каталоге
```bash
       newfstatat(AT_FDCWD, "/root/.magic.mgc", 0xffffdcf52d68, 0) = -1 ENOENT (No such file or directory)
       newfstatat(AT_FDCWD, "/root/.magic", 0xffffdcf52d68, 0) = -1 ENOENT (No such file or directory)
       openat(AT_FDCWD, "/etc/magic.mgc", O_RDONLY) = -1 ENOENT (No such file or directory)
       newfstatat(AT_FDCWD, "/etc/magic", {st_mode=S_IFREG|0644, st_size=111, ...}, 0) = 0
       openat(AT_FDCWD, "/etc/magic", O_RDONLY) = 3
```


## 3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).

``bash
       /proc/<pid>/fd/
       cat /dev/null > /proc/<pid>/fd/<file descriptor>
``


## 4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?
Нет, не занимают, а просто присутствуют.


## 5. В iovisor BCC есть утилита opensnoop

```bash
       root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
       /usr/sbin/opensnoop-bpfcc
       root@vagrant:~# /usr/sbin/opensnoop-bpfcc
       PID    COMM               FD ERR PATH
       775    vminfo              6   0 /var/run/utmp
       563    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services
       563    dbus-daemon        18   0 /usr/share/dbus-1/system-services
       563    dbus-daemon        -1   2 /lib/dbus-1/system-services
       563    dbus-daemon        18   0 /var/lib/snapd/dbus-1/system-services/
```

## 6. Какой системный вызов использует ``uname -a``? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в ``/proc``, где можно узнать версию ядра и релиз ОС.

``execve("/usr/bin/uname", ["uname", "-a"], 0xffffc10bec68 /* 20 vars */) = 0``

Она использует системный вызов `uname`.

`man 2 uname` говорит нам:
> <...>  
>        Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.
 

# 7. Чем отличается последовательность команд через ; и через && в bash? Например
```bash
       root@netology1:~# test -d /tmp/some_dir; echo Hi
       Hi
       root@netology1:~# test -d /tmp/some_dir && echo Hi
       root@netology1:~#
```

Команды, разделенные `;`, выполняются последовательно. Shell ждет завершения обеих команд по очереди. В приведенном в задании примере — Hi выведется в любом случае, эта команда исполнится после `test`.

Команды, разделенные `&&`, выполняются вместе: команда справа от `&&` (command2) выполняется тогда и только тогда, когда команда слева от разделителя (command1) возвращает 0 (выполняется успешно). В примере — Hi будет выведен только если `/tmp/some_dir` существует и является директорией.

#Есть ли смысл использовать в bash &&, если применить set -e?

Возможно зависит от контекста использования, ``&&`` это в первую очередь логический оператор.
Если это просто команда в терминале, то нет, смысла нет, в любом случае обе команды выполнятся только если обе вернут 0.

# 8. Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях?
`-e`, как мы обсудили в предыдущем задании, прекращает выполнение сценария, если команда возвращает ненулевое значение.  
`-u` требует, чтобы все используемые переменные были предварительно объявлены. Если переменная не была предварительная объявлена, она воспринимается как ошибка и выполнение скрипта прекращается. Это хорошая программистская практика, мы знаем, какие переменные используются в коде, они объявляются глобально, не могут быть ошибочно перезаписаны, и их легче найти в коде.  
`-x` выводит все исполняемые команды и их аргументы. Необходимо для debugging'а.  
`-o pipefail` возвращает 0 из всего скрипта только если все команды в нем выполняются успешно. Это полезно, чтобы убедиться, что все выполняемые команды завершились успешно и мы не получили ошибочно код успешного завершения.


По сути, для сценария , повышает деталезацию вывода ошибок(логирования), 
и завершит сценарий при наличии ошибок, на любом этапе выполнения сценария, кроме последней завершающей команды

# 9. Используя ``-o stat`` для ``ps``, определите, какой наиболее часто встречающийся статус у процессов в системе. В ``man ps`` ознакомьтесь ``(/PROCESS STATE CODES)`` что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать ``S``, ``Ss`` или ``Ssl`` равнозначными).

S* - Процесс, который находится в прерываемом сне и при этом является session-лидером. Это означает, что id сессии идентичен id процесса.

R* - работающий процесс, который является foreground-процессом, то есть процессом, о котором знает пользователь, и который требут или запуска пользователем, или какого-то взаимодействия с пользователем.

доп символы это доп характеристики, например приоритет.